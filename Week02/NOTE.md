# 学习笔记

## 哈希表 Hash Table

### 定义
哈希表也叫散列表、Hash 表，是根据关键码值（Key value）直接进行访问的数据结构。将 key 映射为数组下标的的函数，叫做散列函数（Hash Function），记为 `hash(key)`。

> 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。  

![](Assets/434D2C15-049D-4500-B45A-4E03FAB19516.png)


### 散列函数的设计要求
1. 散列值是一个非负整数。
2. 如果 `key1 = key2`，那么 `hash(key1) == hash(key2)`。
3. 如果 `key1 != key2`，那么 `hash(key1) != hash(key2)`。

> 首先，散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。  
> 其次，散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。  

简单的说就是：简单 + 均匀。


### 常见的哈希算法
* [MD5](https://zh.wikipedia.org/wiki/MD5)
* [SHA家族](https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)
* [循環冗餘校驗](https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97)


### 时间复杂度
![](Assets/9562E19F-C757-4E8B-9AEB-5374E3E67DE1.png)

添加、删除和查询都是 O(1)，散列冲突的极限情况退化为 O(n)，树化可能退化为 O(log n)。


### 散列冲突 Collision
如果不同的输入得到了同一个哈希值，就发生了"哈希碰撞"（collision）。

![](Assets/bg2018090510.png)

通过 [鴿巢原理](https://zh.wikipedia.org/wiki/%E9%B4%BF%E5%B7%A2%E5%8E%9F%E7%90%86) 可知，散列冲突不可避免，常见的解决散列冲突的方法有两种，开放寻址法（Open Addressing）和链表法（Chaining）。

#### 开放寻址法

当遇到散列冲突时，寻找其他未被占用的位置，具体探测方法包括：

	1. 线性探测（Linear Probing）：冲突后依次往后找空闲位置。删除时不可直接删除，而是做删除标记，查找到碰到删除标记后要跳过继续查找，否则以后探测到这个位置，其后面就会探测不到导致算法失效。极端情况时间复杂度退化到 O(n)。
	2. 二次探测（Quadratic Probing）：探测步长变为原来的二次方。
	3. 双重散列（Double Hashing）：使用一组散列函数，冲突时更换散列函数寻找空闲位置。

![](Assets/0A3E5E8B-1A92-4950-A061-B9197D740386.png)

JDK 中 ThreadLocalMap 就是采用的开放寻址法解决散列冲突。

#### 链表法

对于冲突的 key，使用链表的数据结构来存储。查找的时间复杂度跟链表长度 k 成正比，即 O(k)。所以要求散列函数的结果均匀，否则极端情况就退化成了链表。JDK 的 HashMap 中，链表长度大于 8 还会树化为红黑树，进一步进行性能优化 O(log n)。

![](Assets/D0BB4A31-01DD-4DC8-A970-56C0B98D5D48.png)

JDK 中 HashMap 采用了链表法解决动态扩容。


#### 🤔 开放寻址法 VS 链表法，各有什么优势和劣势？

> **链表法比起开放寻址法，对大装载因子的容忍度更高。**开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。  

对象大、数据量大的情况，链表法更好更灵活，还可以优化为红黑树等等。

> 链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。  

链表法更加消耗内存和 CPU 资源。对于小对象及小数据量存储场景，更适合用开放寻址法。


### 装载因子（负载因子） Load Factor 
表示空位的多少的参数，其计算公式为：

```
装载因子 = 填入表中元素个数 / 散列表长度
```

**装载因子不能太大，否则空闲位置过少，冲突越多，性能下降越多，空间利用率低。**

#### 🤔 如果装载因子过大，怎么办？

动态扩容。

> 重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。  

> 装载因子阈值的设置要权衡时间、空间复杂度。  
> 如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；  
> 相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。  


### 扩容 Resize
```
threshold = capacity * loadFactor
```

一旦 map 中键值对数量达到了 threshold，则会触发 resize 进行扩容，扩容如果导致 hash 结果变化，还需要 rehash。这里 JDK1.7 和 JDK1.8 的是实现有区别。

#### 🤔 如何避低效扩容？

> 当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。  

> 这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。  


### 散列表的应用
* Work 文档中的单词拼写检查，常用英文单词 20 万个，假设平均长度是 10 个字母，占用 10 个字节，20 万单词占用 2MB 空间，可以满足现代计算机内存空间占用。


#### 🤔 何为一个工业级的散列表？工业级的散列表应该具有哪些特性？

	* 支持快速的查询、插入、删除操作。
	* 内存占用合理，不能浪费过多的内存空间。
	* 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。

#### 🤔 如何实现这样一个散列表呢？

	* 设计一个合适的散列函数。
	* 定义装载因子阈值，并且设计动态扩容策略。
	* 选择合适的散列冲突解决方法。


### 🤔 思考题
    * 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
    A：以 URL 为 key，访问次数为 value，存储于散列表中，然后通过排序算法根据 value 排序。存储 O(n)，排序 O(log n)。
    
    * 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？
    A：遍历较长的数组，存于散列表。第二次遍历另一数组，然后判断是否包含在散列表中。两次遍历 O(m + n)。


### Reference
* [哈希碰撞与生日攻击 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html)
* [18 | 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？-极客时间](https://time.geekbang.org/column/article/64233)
* [19 | 散列表（中）：如何打造一个工业级水平的散列表？-极客时间](https://time.geekbang.org/column/article/64586)
* [20 | 散列表（下）：为什么散列表和链表经常会一起使用？-极客时间](https://time.geekbang.org/column/article/64858)
* [生日攻击 - 维基百科，自由的百科全书](https://zh.wikipedia.org/zh-hans/%E7%94%9F%E6%97%A5%E6%94%BB%E5%87%BB)