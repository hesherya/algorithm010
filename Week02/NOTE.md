# å­¦ä¹ ç¬”è®°

## å“ˆå¸Œè¡¨ Hash Table

### å®šä¹‰

å“ˆå¸Œè¡¨ä¹Ÿå«æ•£åˆ—è¡¨ã€Hash è¡¨ï¼Œæ˜¯æ ¹æ®å…³é”®ç å€¼ï¼ˆKey valueï¼‰ç›´æ¥è¿›è¡Œè®¿é—®çš„æ•°æ®ç»“æ„ã€‚å°† key æ˜ å°„ä¸ºæ•°ç»„ä¸‹æ ‡çš„çš„å‡½æ•°ï¼Œå«åšæ•£åˆ—å‡½æ•°ï¼ˆHash Functionï¼‰ï¼Œè®°ä¸º `hash(key)`ã€‚

> æ•£åˆ—è¡¨ç”¨çš„æ˜¯æ•°ç»„æ”¯æŒæŒ‰ç…§ä¸‹æ ‡éšæœºè®¿é—®æ•°æ®çš„ç‰¹æ€§ï¼Œæ‰€ä»¥æ•£åˆ—è¡¨å…¶å®å°±æ˜¯æ•°ç»„çš„ä¸€ç§æ‰©å±•ï¼Œç”±æ•°ç»„æ¼”åŒ–è€Œæ¥ã€‚å¯ä»¥è¯´ï¼Œå¦‚æœæ²¡æœ‰æ•°ç»„ï¼Œå°±æ²¡æœ‰æ•£åˆ—è¡¨ã€‚

![Hash Table å›¾](Assets/434D2C15-049D-4500-B45A-4E03FAB19516.png)

### æ•£åˆ—å‡½æ•°çš„è®¾è®¡è¦æ±‚

    1. æ•£åˆ—å€¼æ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•°ã€‚
    2. å¦‚æœ `key1 = key2`ï¼Œé‚£ä¹ˆ `hash(key1) == hash(key2)`ã€‚
    3. å¦‚æœ `key1 != key2`ï¼Œé‚£ä¹ˆ `hash(key1) != hash(key2)`ã€‚

> é¦–å…ˆï¼Œæ•£åˆ—å‡½æ•°çš„è®¾è®¡ä¸èƒ½å¤ªå¤æ‚ã€‚è¿‡äºå¤æ‚çš„æ•£åˆ—å‡½æ•°ï¼ŒåŠ¿å¿…ä¼šæ¶ˆè€—å¾ˆå¤šè®¡ç®—æ—¶é—´ï¼Œä¹Ÿå°±é—´æ¥çš„å½±å“åˆ°æ•£åˆ—è¡¨çš„æ€§èƒ½ã€‚
> å…¶æ¬¡ï¼Œæ•£åˆ—å‡½æ•°ç”Ÿæˆçš„å€¼è¦å°½å¯èƒ½éšæœºå¹¶ä¸”å‡åŒ€åˆ†å¸ƒï¼Œè¿™æ ·æ‰èƒ½é¿å…æˆ–è€…æœ€å°åŒ–æ•£åˆ—å†²çªï¼Œè€Œä¸”å³ä¾¿å‡ºç°å†²çªï¼Œæ•£åˆ—åˆ°æ¯ä¸ªæ§½é‡Œçš„æ•°æ®ä¹Ÿä¼šæ¯”è¾ƒå¹³å‡ï¼Œä¸ä¼šå‡ºç°æŸä¸ªæ§½å†…æ•°æ®ç‰¹åˆ«å¤šçš„æƒ…å†µã€‚

ç®€å•çš„è¯´å°±æ˜¯ï¼šç®€å• + å‡åŒ€ã€‚

### å¸¸è§çš„å“ˆå¸Œç®—æ³•

* [MD5](https://zh.wikipedia.org/wiki/MD5)
* [SHAå®¶æ—](https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)
* [å¾ªç’°å†—é¤˜æ ¡é©—](https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97)

### æ—¶é—´å¤æ‚åº¦

![å¤æ‚åº¦åˆ†æå›¾](Assets/9562E19F-C757-4E8B-9AEB-5374E3E67DE1.png)

æ·»åŠ ã€åˆ é™¤å’ŒæŸ¥è¯¢éƒ½æ˜¯ O(1)ï¼Œæ•£åˆ—å†²çªçš„æé™æƒ…å†µé€€åŒ–ä¸º O(n)ï¼Œæ ‘åŒ–å¯èƒ½é€€åŒ–ä¸º O(log n)ã€‚

### æ•£åˆ—å†²çª Collision

å¦‚æœä¸åŒçš„è¾“å…¥å¾—åˆ°äº†åŒä¸€ä¸ªå“ˆå¸Œå€¼ï¼Œå°±å‘ç”Ÿäº†"å“ˆå¸Œç¢°æ’"ï¼ˆcollisionï¼‰ã€‚

![Collsion å›¾](Assets/bg2018090510.png)

é€šè¿‡ [é´¿å·¢åŸç†](https://zh.wikipedia.org/wiki/%E9%B4%BF%E5%B7%A2%E5%8E%9F%E7%90%86) å¯çŸ¥ï¼Œæ•£åˆ—å†²çªä¸å¯é¿å…ï¼Œå¸¸è§çš„è§£å†³æ•£åˆ—å†²çªçš„æ–¹æ³•æœ‰ä¸¤ç§ï¼Œå¼€æ”¾å¯»å€æ³•ï¼ˆOpen Addressingï¼‰å’Œé“¾è¡¨æ³•ï¼ˆChainingï¼‰ã€‚

#### å¼€æ”¾å¯»å€æ³•

å½“é‡åˆ°æ•£åˆ—å†²çªæ—¶ï¼Œå¯»æ‰¾å…¶ä»–æœªè¢«å ç”¨çš„ä½ç½®ï¼Œå…·ä½“æ¢æµ‹æ–¹æ³•åŒ…æ‹¬ï¼š

    1. çº¿æ€§æ¢æµ‹ï¼ˆLinear Probingï¼‰ï¼šå†²çªåä¾æ¬¡å¾€åæ‰¾ç©ºé—²ä½ç½®ã€‚åˆ é™¤æ—¶ä¸å¯ç›´æ¥åˆ é™¤ï¼Œè€Œæ˜¯åšåˆ é™¤æ ‡è®°ï¼ŒæŸ¥æ‰¾åˆ°ç¢°åˆ°åˆ é™¤æ ‡è®°åè¦è·³è¿‡ç»§ç»­æŸ¥æ‰¾ï¼Œå¦åˆ™ä»¥åæ¢æµ‹åˆ°è¿™ä¸ªä½ç½®ï¼Œå…¶åé¢å°±ä¼šæ¢æµ‹ä¸åˆ°å¯¼è‡´ç®—æ³•å¤±æ•ˆã€‚æç«¯æƒ…å†µæ—¶é—´å¤æ‚åº¦é€€åŒ–åˆ° O(n)ã€‚
    2. äºŒæ¬¡æ¢æµ‹ï¼ˆQuadratic Probingï¼‰ï¼šæ¢æµ‹æ­¥é•¿å˜ä¸ºåŸæ¥çš„äºŒæ¬¡æ–¹ã€‚
    3. åŒé‡æ•£åˆ—ï¼ˆDouble Hashingï¼‰ï¼šä½¿ç”¨ä¸€ç»„æ•£åˆ—å‡½æ•°ï¼Œå†²çªæ—¶æ›´æ¢æ•£åˆ—å‡½æ•°å¯»æ‰¾ç©ºé—²ä½ç½®ã€‚

![å¼€æ”¾å¯»å€æ³•å›¾](Assets/0A3E5E8B-1A92-4950-A061-B9197D740386.png)

JDK ä¸­ ThreadLocalMap å°±æ˜¯é‡‡ç”¨çš„å¼€æ”¾å¯»å€æ³•è§£å†³æ•£åˆ—å†²çªã€‚

#### é“¾è¡¨æ³•

å¯¹äºå†²çªçš„ keyï¼Œä½¿ç”¨é“¾è¡¨çš„æ•°æ®ç»“æ„æ¥å­˜å‚¨ã€‚æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦è·Ÿé“¾è¡¨é•¿åº¦ k æˆæ­£æ¯”ï¼Œå³ O(k)ã€‚æ‰€ä»¥è¦æ±‚æ•£åˆ—å‡½æ•°çš„ç»“æœå‡åŒ€ï¼Œå¦åˆ™æç«¯æƒ…å†µå°±é€€åŒ–æˆäº†é“¾è¡¨ã€‚JDK çš„ HashMap ä¸­ï¼Œé“¾è¡¨é•¿åº¦å¤§äº 8 è¿˜ä¼šæ ‘åŒ–ä¸ºçº¢é»‘æ ‘ï¼Œè¿›ä¸€æ­¥è¿›è¡Œæ€§èƒ½ä¼˜åŒ– O(log n)ã€‚

![é“¾è¡¨æ³•å›¾](Assets/D0BB4A31-01DD-4DC8-A970-56C0B98D5D48.png)

JDK ä¸­ HashMap é‡‡ç”¨äº†é“¾è¡¨æ³•è§£å†³åŠ¨æ€æ‰©å®¹ã€‚

#### ğŸ¤” å¼€æ”¾å¯»å€æ³• VS é“¾è¡¨æ³•ï¼Œå„æœ‰ä»€ä¹ˆä¼˜åŠ¿å’ŒåŠ£åŠ¿

> **é“¾è¡¨æ³•æ¯”èµ·å¼€æ”¾å¯»å€æ³•ï¼Œå¯¹å¤§è£…è½½å› å­çš„å®¹å¿åº¦æ›´é«˜ã€‚**å¼€æ”¾å¯»å€æ³•åªèƒ½é€‚ç”¨è£…è½½å› å­å°äº 1 çš„æƒ…å†µã€‚æ¥è¿‘ 1 æ—¶ï¼Œå°±å¯èƒ½ä¼šæœ‰å¤§é‡çš„æ•£åˆ—å†²çªï¼Œå¯¼è‡´å¤§é‡çš„æ¢æµ‹ã€å†æ•£åˆ—ç­‰ï¼Œæ€§èƒ½ä¼šä¸‹é™å¾ˆå¤šã€‚ä½†æ˜¯å¯¹äºé“¾è¡¨æ³•æ¥è¯´ï¼Œåªè¦æ•£åˆ—å‡½æ•°çš„å€¼éšæœºå‡åŒ€ï¼Œå³ä¾¿è£…è½½å› å­å˜æˆ 10ï¼Œä¹Ÿå°±æ˜¯é“¾è¡¨çš„é•¿åº¦å˜é•¿äº†è€Œå·²ï¼Œè™½ç„¶æŸ¥æ‰¾æ•ˆç‡æœ‰æ‰€ä¸‹é™ï¼Œä½†æ˜¯æ¯”èµ·é¡ºåºæŸ¥æ‰¾è¿˜æ˜¯å¿«å¾ˆå¤šã€‚

å¯¹è±¡å¤§ã€æ•°æ®é‡å¤§çš„æƒ…å†µï¼Œé“¾è¡¨æ³•æ›´å¥½æ›´çµæ´»ï¼Œè¿˜å¯ä»¥ä¼˜åŒ–ä¸ºçº¢é»‘æ ‘ç­‰ç­‰ã€‚

> é“¾è¡¨å› ä¸ºè¦å­˜å‚¨æŒ‡é’ˆï¼Œæ‰€ä»¥å¯¹äºæ¯”è¾ƒå°çš„å¯¹è±¡çš„å­˜å‚¨ï¼Œæ˜¯æ¯”è¾ƒæ¶ˆè€—å†…å­˜çš„ï¼Œè¿˜æœ‰å¯èƒ½ä¼šè®©å†…å­˜çš„æ¶ˆè€—ç¿»å€ã€‚è€Œä¸”ï¼Œå› ä¸ºé“¾è¡¨ä¸­çš„ç»“ç‚¹æ˜¯é›¶æ•£åˆ†å¸ƒåœ¨å†…å­˜ä¸­çš„ï¼Œä¸æ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥å¯¹ CPU ç¼“å­˜æ˜¯ä¸å‹å¥½çš„ï¼Œè¿™æ–¹é¢å¯¹äºæ‰§è¡Œæ•ˆç‡ä¹Ÿæœ‰ä¸€å®šçš„å½±å“ã€‚

é“¾è¡¨æ³•æ›´åŠ æ¶ˆè€—å†…å­˜å’Œ CPU èµ„æºã€‚å¯¹äºå°å¯¹è±¡åŠå°æ•°æ®é‡å­˜å‚¨åœºæ™¯ï¼Œæ›´é€‚åˆç”¨å¼€æ”¾å¯»å€æ³•ã€‚

### è£…è½½å› å­ï¼ˆè´Ÿè½½å› å­ï¼‰ Load Factor

è¡¨ç¤ºç©ºä½çš„å¤šå°‘çš„å‚æ•°ï¼Œå…¶è®¡ç®—å…¬å¼ä¸ºï¼š`è£…è½½å› å­ = å¡«å…¥è¡¨ä¸­å…ƒç´ ä¸ªæ•° / æ•£åˆ—è¡¨é•¿åº¦`

**è£…è½½å› å­ä¸èƒ½å¤ªå¤§ï¼Œå¦åˆ™ç©ºé—²ä½ç½®è¿‡å°‘ï¼Œå†²çªè¶Šå¤šï¼Œæ€§èƒ½ä¸‹é™è¶Šå¤šï¼Œç©ºé—´åˆ©ç”¨ç‡ä½ã€‚**

#### ğŸ¤” å¦‚æœè£…è½½å› å­è¿‡å¤§ï¼Œæ€ä¹ˆåŠ

åŠ¨æ€æ‰©å®¹ã€‚

> é‡æ–°ç”³è¯·ä¸€ä¸ªæ›´å¤§çš„æ•£åˆ—è¡¨ï¼Œå°†æ•°æ®æ¬ç§»åˆ°è¿™ä¸ªæ–°æ•£åˆ—è¡¨ä¸­ã€‚å‡è®¾æ¯æ¬¡æ‰©å®¹æˆ‘ä»¬éƒ½ç”³è¯·ä¸€ä¸ªåŸæ¥æ•£åˆ—è¡¨å¤§å°ä¸¤å€çš„ç©ºé—´ã€‚å¦‚æœåŸæ¥æ•£åˆ—è¡¨çš„è£…è½½å› å­æ˜¯ 0.8ï¼Œé‚£ç»è¿‡æ‰©å®¹ä¹‹åï¼Œæ–°æ•£åˆ—è¡¨çš„è£…è½½å› å­å°±ä¸‹é™ä¸ºåŸæ¥çš„ä¸€åŠï¼Œå˜æˆäº† 0.4ã€‚
> è£…è½½å› å­é˜ˆå€¼çš„è®¾ç½®è¦æƒè¡¡æ—¶é—´ã€ç©ºé—´å¤æ‚åº¦ã€‚
> å¦‚æœå†…å­˜ç©ºé—´ä¸ç´§å¼ ï¼Œå¯¹æ‰§è¡Œæ•ˆç‡è¦æ±‚å¾ˆé«˜ï¼Œå¯ä»¥é™ä½è´Ÿè½½å› å­çš„é˜ˆå€¼ï¼›
> ç›¸åï¼Œå¦‚æœå†…å­˜ç©ºé—´ç´§å¼ ï¼Œå¯¹æ‰§è¡Œæ•ˆç‡è¦æ±‚åˆä¸é«˜ï¼Œå¯ä»¥å¢åŠ è´Ÿè½½å› å­çš„å€¼ï¼Œç”šè‡³å¯ä»¥å¤§äº 1ã€‚

### æ‰©å®¹ Resize

`threshold = capacity * loadFactor`

ä¸€æ—¦ map ä¸­é”®å€¼å¯¹æ•°é‡è¾¾åˆ°äº† thresholdï¼Œåˆ™ä¼šè§¦å‘ resize è¿›è¡Œæ‰©å®¹ï¼Œæ‰©å®¹å¦‚æœå¯¼è‡´ hash ç»“æœå˜åŒ–ï¼Œè¿˜éœ€è¦ rehashã€‚è¿™é‡Œ JDK1.7 å’Œ JDK1.8 çš„æ˜¯å®ç°æœ‰åŒºåˆ«ã€‚

#### ğŸ¤” å¦‚ä½•é¿ä½æ•ˆæ‰©å®¹

> 1. å½“æœ‰æ–°æ•°æ®è¦æ’å…¥æ—¶ï¼Œæˆ‘ä»¬å°†æ–°æ•°æ®æ’å…¥æ–°æ•£åˆ—è¡¨ä¸­ï¼Œå¹¶ä¸”ä»è€çš„æ•£åˆ—è¡¨ä¸­æ‹¿å‡ºä¸€ä¸ªæ•°æ®æ”¾å…¥åˆ°æ–°æ•£åˆ—è¡¨ã€‚æ¯æ¬¡æ’å…¥ä¸€ä¸ªæ•°æ®åˆ°æ•£åˆ—è¡¨ï¼Œæˆ‘ä»¬éƒ½é‡å¤ä¸Šé¢çš„è¿‡ç¨‹ã€‚ç»è¿‡å¤šæ¬¡æ’å…¥æ“ä½œä¹‹åï¼Œè€çš„æ•£åˆ—è¡¨ä¸­çš„æ•°æ®å°±ä¸€ç‚¹ä¸€ç‚¹å…¨éƒ¨æ¬ç§»åˆ°æ–°æ•£åˆ—è¡¨ä¸­äº†ã€‚è¿™æ ·æ²¡æœ‰äº†é›†ä¸­çš„ä¸€æ¬¡æ€§æ•°æ®æ¬ç§»ï¼Œæ’å…¥æ“ä½œå°±éƒ½å˜å¾—å¾ˆå¿«äº†ã€‚
> 2. è¿™æœŸé—´çš„æŸ¥è¯¢æ“ä½œæ€ä¹ˆæ¥åšå‘¢ï¼Ÿå¯¹äºæŸ¥è¯¢æ“ä½œï¼Œä¸ºäº†å…¼å®¹äº†æ–°ã€è€æ•£åˆ—è¡¨ä¸­çš„æ•°æ®ï¼Œæˆ‘ä»¬å…ˆä»æ–°æ•£åˆ—è¡¨ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå†å»è€çš„æ•£åˆ—è¡¨ä¸­æŸ¥æ‰¾ã€‚

### æ•£åˆ—è¡¨çš„åº”ç”¨

* Work æ–‡æ¡£ä¸­çš„å•è¯æ‹¼å†™æ£€æŸ¥ï¼Œå¸¸ç”¨è‹±æ–‡å•è¯ 20 ä¸‡ä¸ªï¼Œå‡è®¾å¹³å‡é•¿åº¦æ˜¯ 10 ä¸ªå­—æ¯ï¼Œå ç”¨ 10 ä¸ªå­—èŠ‚ï¼Œ20 ä¸‡å•è¯å ç”¨ 2MB ç©ºé—´ï¼Œå¯ä»¥æ»¡è¶³ç°ä»£è®¡ç®—æœºå†…å­˜ç©ºé—´å ç”¨ã€‚

#### ğŸ¤” ä½•ä¸ºä¸€ä¸ªå·¥ä¸šçº§çš„æ•£åˆ—è¡¨ï¼Ÿå·¥ä¸šçº§çš„æ•£åˆ—è¡¨åº”è¯¥å…·æœ‰å“ªäº›ç‰¹æ€§

* æ”¯æŒå¿«é€Ÿçš„æŸ¥è¯¢ã€æ’å…¥ã€åˆ é™¤æ“ä½œã€‚
* å†…å­˜å ç”¨åˆç†ï¼Œä¸èƒ½æµªè´¹è¿‡å¤šçš„å†…å­˜ç©ºé—´ã€‚
* æ€§èƒ½ç¨³å®šï¼Œæç«¯æƒ…å†µä¸‹ï¼Œæ•£åˆ—è¡¨çš„æ€§èƒ½ä¹Ÿä¸ä¼šé€€åŒ–åˆ°æ— æ³•æ¥å—çš„æƒ…å†µã€‚

#### ğŸ¤” å¦‚ä½•å®ç°è¿™æ ·ä¸€ä¸ªæ•£åˆ—è¡¨å‘¢

* è®¾è®¡ä¸€ä¸ªåˆé€‚çš„æ•£åˆ—å‡½æ•°ã€‚
* å®šä¹‰è£…è½½å› å­é˜ˆå€¼ï¼Œå¹¶ä¸”è®¾è®¡åŠ¨æ€æ‰©å®¹ç­–ç•¥ã€‚
* é€‰æ‹©åˆé€‚çš„æ•£åˆ—å†²çªè§£å†³æ–¹æ³•ã€‚

### ğŸ¤” æ€è€ƒé¢˜

* å‡è®¾æˆ‘ä»¬æœ‰ 10 ä¸‡æ¡ URL è®¿é—®æ—¥å¿—ï¼Œå¦‚ä½•æŒ‰ç…§è®¿é—®æ¬¡æ•°ç»™ URL æ’åºï¼Ÿ
Aï¼šä»¥ URL ä¸º keyï¼Œè®¿é—®æ¬¡æ•°ä¸º valueï¼Œå­˜å‚¨äºæ•£åˆ—è¡¨ä¸­ï¼Œç„¶åé€šè¿‡æ’åºç®—æ³•æ ¹æ® value æ’åºã€‚å­˜å‚¨ O(n)ï¼Œæ’åº O(log n)ã€‚

* æœ‰ä¸¤ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„å¤§çº¦æœ‰ 10 ä¸‡æ¡å­—ç¬¦ä¸²ï¼Œå¦‚ä½•å¿«é€Ÿæ‰¾å‡ºä¸¤ä¸ªæ•°ç»„ä¸­ç›¸åŒçš„å­—ç¬¦ä¸²ï¼Ÿ
Aï¼šéå†è¾ƒé•¿çš„æ•°ç»„ï¼Œå­˜äºæ•£åˆ—è¡¨ã€‚ç¬¬äºŒæ¬¡éå†å¦ä¸€æ•°ç»„ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦åŒ…å«åœ¨æ•£åˆ—è¡¨ä¸­ã€‚ä¸¤æ¬¡éå† O(m + n)ã€‚

### Reference

* [å“ˆå¸Œç¢°æ’ä¸ç”Ÿæ—¥æ”»å‡» - é˜®ä¸€å³°çš„ç½‘ç»œæ—¥å¿—](http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html)
* [18 | æ•£åˆ—è¡¨ï¼ˆä¸Šï¼‰ï¼šWordæ–‡æ¡£ä¸­çš„å•è¯æ‹¼å†™æ£€æŸ¥åŠŸèƒ½æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ-æå®¢æ—¶é—´](https://time.geekbang.org/column/article/64233)
* [19 | æ•£åˆ—è¡¨ï¼ˆä¸­ï¼‰ï¼šå¦‚ä½•æ‰“é€ ä¸€ä¸ªå·¥ä¸šçº§æ°´å¹³çš„æ•£åˆ—è¡¨ï¼Ÿ-æå®¢æ—¶é—´](https://time.geekbang.org/column/article/64586)
* [20 | æ•£åˆ—è¡¨ï¼ˆä¸‹ï¼‰ï¼šä¸ºä»€ä¹ˆæ•£åˆ—è¡¨å’Œé“¾è¡¨ç»å¸¸ä¼šä¸€èµ·ä½¿ç”¨ï¼Ÿ-æå®¢æ—¶é—´](https://time.geekbang.org/column/article/64858)
* [ç”Ÿæ—¥æ”»å‡» - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦](https://zh.wikipedia.org/zh-hans/%E7%94%9F%E6%97%A5%E6%94%BB%E5%87%BB)

# JDK HashMap æºç åˆ†æ

## put

put æ–¹æ³•è°ƒç”¨äº† putVal æ–¹æ³•ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å¯¹ key åº”ç”¨äº†æ•£åˆ—å‡½æ•°ã€‚

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

åœ¨æ•£åˆ—å‡½æ•°å†…å¯ä»¥çœ‹åˆ° key ä¸ä¸ºç©ºæ—¶çš„è®¡ç®—é€»è¾‘ï¼Œkey çš„ hashCode ä¸å…¶è‡ªå·±å³ç§»åçš„é«˜ 16 ä½è¿›è¡Œä½å¼‚æˆ–æ“ä½œã€‚

## æ•£åˆ—å‡½æ•°

ä»æ•£åˆ—å‡½æ•°çš„æ³¨é‡Šä¸­å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¹ˆåšæ˜¯ä¸ºäº†å°†é«˜ä½çš„å·®å¼‚å½±å“ä¼ æ’­åˆ°ä½ä½ã€‚

> Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide.  

å› ä¸ºè¡¨ä½¿ç”¨ 2 çš„æ¬¡å¹‚ï¼Œæ‰€ä»¥å¯¹äºåªæœ‰é«˜ä½å˜åŒ–çš„å“ˆå¸Œå€¼ï¼Œå°†æ€»æ˜¯å†²çªã€‚

int å‹çš„ hashCode 32 ä½ï¼Œå³ç§» 16 ä½åé«˜ 16 ä½è¡¥ 0ï¼Œå¼‚æˆ–åçš„ç»“æœï¼Œé«˜ 16 ä½ä¿æŒä¸å˜ï¼Œä½ 16 ä½åˆ™ä¼šå—åˆ°é«˜ä½å½±å“è€Œå˜åŒ–ã€‚

```java
/**
 * Computes key.hashCode() and spreads (XORs) higher bits of hash
 * to lower. Because the table uses power-of-two masking, sets of
 * hashes that vary only in bits above the current mask will
 * always collide. (Among known examples are sets of Float keys
 * holding consecutive whole numbers in small tables.)  So we
 * apply a transform that spreads the impact of higher bits
 * downward. There is a tradeoff between speed, utility, and
 * quality of bit-spreading. Because many common sets of hashes
 * are already reasonably distributed (so don't benefit from
 * spreading), and because we use trees to handle large sets of
 * collisions in bins, we just XOR some shifted bits in the
 * cheapest possible way to reduce systematic lossage, as well as
 * to incorporate impact of the highest bits that would otherwise
 * never be used in index calculations because of table bounds.
 */
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

### ğŸ¤” æ•£åˆ—å‡½æ•°ä½¿ç”¨ key çš„ hashCode ä¸ table çš„é•¿åº¦æ±‚ä½™å–æ¨¡ï¼Œæœ‰ä»€ä¹ˆä¸å¥½ï¼Ÿä¸ºä»€ä¹ˆè¦ç”¨é«˜ä½åå…­ä½åšå¼‚æˆ–

æ±‚æ¨¡ï¼š`index = key.hashCode() % table.length()` æˆ– `index = key.hashCode() & (table.lengh() - 1)`ã€‚

hashCode è¿”å›ç±»å‹ä¸º intï¼Œå  4 å­—èŠ‚ 32 ä½ã€‚ç”±äºç¡®å®šå“ˆå¸Œè¡¨ä¸­æ¡¶çš„ä½ç½®ä½¿ç”¨çš„æ˜¯æ±‚æ¨¡è¿ç®—ï¼Œæ‰€ä»¥æ•°ç»„é•¿åº¦åœ¨è¾ƒå°æ—¶ï¼Œåªèƒ½ååº”å‡º hashCode ä¸­ä½ä½çš„å˜åŒ–ï¼Œå¾ˆå®¹æ˜“æ•£åˆ—å†²çªã€‚å³ç§»åå…­ä½åšå¼‚æˆ–å°±å¼¥è¡¥äº†è¿™ä¸ªç¼ºç‚¹ï¼Œå¯¹é«˜ä½çš„å˜åŒ–ï¼Œä¹Ÿèƒ½æç°å‡ºæ¥ï¼Œå‡å°äº†æ•£åˆ—å†²çªçš„æ¦‚ç‡ã€‚

## putVal

åŸºæœ¬é€»è¾‘ï¼š

   1. å…ˆå»ºå“ˆå¸Œè¡¨æ•°ç»„ã€‚
   2. åœ¨æ•°ç»„ä½ç½®å»ºé“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚
   3. å¦‚æœæœ‰æ•£åˆ—å†²çªï¼Œé¡ºç€é“¾è¡¨å¾€åæ’å…¥èŠ‚ç‚¹ã€‚
   4. ç¢°åˆ°ç›¸åŒ key çš„ï¼Œæœ€åå†³å®šæ˜¯å¦è¦†ç›–å…¶å€¼ã€‚
   5. é“¾è¡¨é•¿åº¦å¤§äºç­‰äº 8 æ—¶æ ‘åŒ–ï¼Œæ ‘åŒ–åå†æ·»åŠ èŠ‚ç‚¹å°±æ˜¯ç”¨æ’å…¥æ ‘èŠ‚ç‚¹çš„æ–¹æ³•ã€‚

```java
/**
 * Implements Map.put and related methods.
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don't change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    // å“ˆå¸Œè¡¨ä¸ºç©ºå°±æ–°å»ºå“ˆå¸Œè¡¨æ•°ç»„
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // å¯¹é•¿åº¦å–æ¨¡ç®—å‡ºæ•°ç»„ä¸‹æ ‡ï¼Œæ­¤ä½ç½®ç©ºç€å°±æ–°å»ºèŠ‚ç‚¹
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // èŠ‚ç‚¹ä¸ç©º
    else {
        Node<K,V> e; K k;
        // hash ç›¸åŒå¹¶ä¸” key ç›¸åŒï¼Œè¯´æ˜å·²å­˜åœ¨ï¼ŒæŠŠèŠ‚ç‚¹èµ‹å€¼ç»™ eï¼Œåé¢å†å†³å®šæ˜¯å¦è¦†ç›–å€¼ã€‚
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        // p æ˜¯æ ‘èŠ‚ç‚¹ï¼Œè°ƒç”¨ TreeNode#putTreeVal æ·»åŠ æ ‘èŠ‚ç‚¹
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // æ­£å¸¸æ·»åŠ èŠ‚ç‚¹
        else {
            for (int binCount = 0; ; ++binCount) {
                // å¦‚æœä¸‹ä¸€èŠ‚ç‚¹ä¸ºç©ºå°±æ·»åŠ æ–°èŠ‚ç‚¹
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // æ ‘åŒ–é˜ˆå€¼ TREEIFY_THRESHOLD = 8ï¼Œè¿™é‡Œ binCount ä» 0 å¼€å§‹è®¡æ•°
                    // ä½†ç”±äºæ²¡æœ‰ç®—å¤´ç»“ç‚¹ï¼Œæ‰€ä»¥èŠ‚ç‚¹æ•°å…¶å®æ˜¯å¤§äºç­‰äº 8ï¼Œä¼šè¿›è¡Œæ ‘åŒ–
                    // å¤´ç»“ç‚¹åé¢çš„èŠ‚ç‚¹ï¼Œè¢«å½¢å®¹ä¸º bin
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                // key å·²å­˜åœ¨ç›´æ¥è·³å‡ºå¾ªç¯ï¼Œåç»­å†³å®šæ˜¯å¦è¦†ç›–å€¼
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                // ä¸å†²çªçš„æƒ…å†µå¾€é“¾è¡¨åé¢èµ°
                p = e;
            }
        }
        // e ä¸ºå·²å­˜åœ¨çš„èŠ‚ç‚¹ï¼Œæ ¹æ® onlyIfAbsent å†³å®šæ˜¯å¦è¦†ç›–
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            // é’©å­ï¼Œé¢„ç•™ç»™ LinkedHashMap çš„è®¿é—®åå¤„ç†æ–¹æ³•
            afterNodeAccess(e);
            // ä¸ç´¯åŠ æ“ä½œæ¬¡æ•°ï¼Œä¹Ÿä¸ä¼šè°ƒç”¨æ’å…¥åå¤„ç†çš„é’©å­æ–¹æ³•ï¼Œç›´æ¥è¿”å›
            return oldValue;
        }
    }
    // ç´¯åŠ æ“ä½œæ¬¡æ•°
    ++modCount;
    // é•¿åº¦è¶…è¿‡é˜ˆå€¼å°±è¿›è¡Œæ‰©å®¹
    if (++size > threshold)
        resize();
    // é’©å­ï¼Œé¢„ç•™ç»™ LinkedHashMap çš„æ’å…¥åå¤„ç†æ–¹æ³•
    afterNodeInsertion(evict);
    return null;
}
```

çœ‹ä¸€ä¸‹é“¾è¡¨çš„èŠ‚ç‚¹ Node ç»“æ„ï¼Œé™¤äº† keyã€valueã€next ä¹‹å¤–ï¼Œè¿˜æœ‰ hashã€‚

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    ......
}
```

## resize

å†çœ‹æ‰©å®¹æ–¹æ³•ï¼Œæœ‰ä¸¤ä¸ªåŠŸèƒ½ï¼Œä¸€ä¸ªæ˜¯æ‰©å®¹ï¼Œå¦ä¸€ä¸ªæ˜¯åˆå§‹åŒ–ã€‚

å…ˆè´´ä¸€ä¸‹é˜ˆå€¼è®¡ç®—å…¬å¼ï¼š`threshold = capacity * loadFactor`ã€‚

æ‰©å®¹ç”±äºè¦éå†æ•°ç»„åŠé“¾è¡¨ï¼Œæ—¶é—´å¤æ‚åº¦ O(n^2)ã€‚

åŸºæœ¬é€»è¾‘ï¼š
    1. å¦‚å·²æœ‰æ•°æ®ï¼Œå®¹é‡å’Œé˜ˆå€¼ç¿»å€ ï¼Œå¦åˆ™åˆå§‹åŒ–å®¹é‡å’Œé˜ˆå€¼ã€‚
    2. åˆ›å»ºæ–°çš„å“ˆå¸Œè¡¨æ•°ç»„ï¼Œéå†åŸå“ˆå¸Œè¡¨ï¼Œå°†åŸæ¥é“¾è¡¨ä¸­çš„å…ƒç´ æ”¾åˆ°æ–°å“ˆå¸Œè¡¨ä¸­åŸæ•°ç»„åŠæ–°å¢æ•°ç»„çš„ä¸¤ä¸ªé“¾è¡¨ä¸­ã€‚

```java
/**
 * Initializes or doubles table size.  If null, allocates in
 * accord with initial capacity target held in field threshold.
 * Otherwise, because we are using power-of-two expansion, the
 * elements from each bin must either stay at same index, or move
 * with a power of two offset in the new table.
 *
 * @return the table
 */
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        // æ£€æŸ¥å®¹é‡ä¸Šé™ï¼Œæœ€å¤§åªèƒ½åˆ°æ•´æ•°æœ€å¤§å€¼
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // æ–°å®¹é‡å’Œæ–°é˜ˆå€¼æ‰©å®¹ä¸ºåŸå®¹é‡å’ŒåŸé˜ˆå€¼çš„ä¸¤å€
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    // å·²åˆå§‹åŒ–è¿‡é˜ˆå€¼ï¼Œæ¯”å¦‚é€šè¿‡å¸¦å‚æ•°æ„é€ æ–¹æ³•æ–°å»º
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    // åˆå§‹åŒ–é˜ˆå€¼ï¼Œé»˜è®¤å®¹é‡ 16ï¼Œé˜ˆå€¼ä¸º 16 * 0.75f
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    // åˆ›å»ºæ–°å“ˆå¸Œè¡¨
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // éå†å“ˆå¸Œè¡¨
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                // æŠŠæ•°ç»„ä¸­æ¯ä¸ªé“¾è¡¨å¤´ç»“ç‚¹æ¸…ç©º
                oldTab[j] = null;
                // å¤´ç»“ç‚¹åé¢æ²¡æœ‰èŠ‚ç‚¹æ—¶ï¼ŒæŠŠå…ƒç´ æ”¾å…¥æ‰©å®¹åå‡ºè®¡ç®—å‡ºæ¥çš„ä¸‹æ ‡ä½ç½®ä¸Š
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                // å¤´ç»“ç‚¹æ˜¯æ ‘èŠ‚ç‚¹ï¼Œè°ƒç”¨ TreeNode#split å¤„ç†
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
               // å¤´ç»“ç‚¹åé¢æœ‰å…ƒç´ çš„æƒ…å†µ
                else { // preserve order
                    // åŸé“¾è¡¨å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹
                    Node<K,V> loHead = null, loTail = null;
                    // æ–°é“¾è¡¨å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    // éå†é“¾è¡¨
                    do {
                        next = e.next;
                        // é€šè¿‡èŠ‚ç‚¹å“ˆå¸Œä¸åŸå®¹é‡åšä½ä¸
                        // åˆ¤æ–­ç»“æœæ˜¯å¦ç­‰äº 0ï¼Œæ¥åŒºåˆ†èŠ‚ç‚¹åœ¨æ–°æ•°ç»„ä¸­çš„åŸæ•°ç»„éƒ¨åˆ†è¿˜æ˜¯æ–°å¢æ•°ç»„éƒ¨åˆ†
                        // è¿™å°±æŠŠåŸé“¾è¡¨æ‹†åˆ†æ”¾å…¥æ–°å“ˆå¸Œè¡¨çš„ä¸¤ä¸ªæ¡¶ä¸­äº†ï¼Œè€Œä½ç½®åŸ index å’Œ oldCap + index
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // åŸé“¾è¡¨å°¾æŒ‡å‘ç©ºï¼Œå¤´æ”¾åˆ°å“ˆå¸Œè¡¨ä¸­
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // æ–°é“¾è¡¨å°¾æŒ‡å‘ç©ºï¼Œå¤´æ”¾åˆ°å“ˆå¸Œè¡¨ä¸­
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

### ğŸ¤” åˆ¤æ–­å…ƒç´ æ”¾å…¥æ–°è¡¨çš„é«˜ä½æ¡¶è¿˜æ˜¯ä½ä½æ¡¶ï¼Œæ˜¯ä»¥ä»€ä¹ˆæ¡ä»¶æ¥åˆ¤æ–­çš„ï¼Ÿä¸ºä»€ä¹ˆè¿™æ ·åˆ¤æ–­

åˆ¤æ–­æ¡ä»¶ï¼š`(e.hash & oldCap) == 0`ã€‚é€šè¿‡å¯¹ oldCap åšä½ä¸æ“ä½œï¼Œå¯ä»¥å°†åŸæ¥é“¾è¡¨ä¸­çš„å…ƒç´ å‡åŒ€ï¼ˆå¦‚æœåŸæ¥çš„å€¼æ˜¯è¿ç»­çš„ï¼‰çš„åˆ†é…åˆ°é«˜ã€ä½é€šç›¸åŒä½ç½®çš„ç´¢å¼•ä¸­ï¼Œå³åŸ index å’Œ index + oldCap ä½ç½®ã€‚é“¾è¡¨ä¸­ä»»æ„ä¸¤ä¸ªè¿ç»­å…ƒç´ ï¼Œç›¸å·® oldCapï¼Œè¿™å°±ä½¿ hashCode çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ï¼ŒoldCap é‚£ä¸€ä½ä¼šå‡ºç°äº¤æ›¿ä¸º 1 çš„æƒ…å†µï¼Œè€Œ capacity è¢«è®¾è®¡ä¸º 2 çš„å¹‚æ¬¡ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€ä½ä¸º 1ã€‚è¿™æ ·ä½ä¸ååˆ¤æ–­æ˜¯å¦ä¸º 0ï¼Œå°±å¯ä»¥æ˜¯è¿ç»­çš„é“¾è¡¨å…ƒç´ åˆ†åˆ«è½åˆ°ä¸åŒçš„æ¡¶ä¸­ã€‚åŒæ—¶ï¼Œç”±äºæœ‰ä¸€åŠ index å¹¶æ²¡æœ‰å˜åŒ–ï¼Œé¿å…äº†ç§»åŠ¨ã€‚

## get

è°ƒç”¨çš„æ ¸å¿ƒæ–¹æ³•æ˜¯ getNodeã€‚

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
```

## getNode

æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯æ±‚æ¨¡ç¡®å®šæ•°ç»„ç´¢å¼•ä½ç½®ï¼Œç„¶åéå†é“¾è¡¨æˆ–è€…æ ‘ã€‚

```java
/**
 * Implements Map.get and related methods.
 *
 * @param hash hash for key
 * @param key the key
 * @return the node, or null if none
 */
final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        // æ£€æŸ¥å¤´èŠ‚ç‚¹
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        // æ£€æŸ¥åç»­èŠ‚ç‚¹
        if ((e = first.next) != null) {
            // æ ‘èŠ‚ç‚¹è°ƒç”¨ TreeNode#getTreeNode æ–¹æ³•å¤„ç†
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            // å‘åéå†
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

# æ ‘ Tree

## æ¦‚å¿µ

* èŠ‚ç‚¹é«˜åº¦ï¼ˆHeightï¼‰ï¼šèŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ï¼ˆè¾¹æ•°ï¼‰ã€‚
* æ·±åº¦ï¼ˆDepthï¼‰ï¼šæ ¹èŠ‚ç‚¹åˆ°è¿™ä¸ªèŠ‚ç‚¹æ‰€ç»å†çš„è¾¹æ•°ã€‚
* å±‚æ•°ï¼ˆLevelï¼‰ï¼šèŠ‚ç‚¹æ·±åº¦ + 1ã€‚
* æ ‘çš„é«˜åº¦ï¼šæ ¹èŠ‚ç‚¹é«˜åº¦ã€‚
    
## äºŒå‰æ ‘ Binary Tree

* ç¬¬ i å±‚æœ€å¤šæœ‰ `2^(i - 1)` ä¸ªèŠ‚ç‚¹ï¼›
* æ·±åº¦ä¸º k çš„äºŒå‰æ ‘æœ€å¤šæ€»å…±å¯ä»¥æœ‰ `2^(k+1)-1` ä¸ªèŠ‚ç‚¹ï¼ˆå®šä¹‰æ ¹èŠ‚ç‚¹æ·±åº¦ä¸º 0ï¼‰ï¼›
* æ‹¥æœ‰æœ€å¤§èŠ‚ç‚¹æ•°çš„äºŒå‰æ ‘æˆä¸ºæ»¡äºŒå‰æ ‘ï¼ˆFull Binary Treeï¼‰ï¼›
* é™¤æœ€åä¸€å±‚ä»¥å¤–ä¸ºæ»¡äºŒå‰æ ‘ï¼Œä¸”æœ€åä¸€å±‚æ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½é å·¦æ’åˆ—çš„äºŒå‰æ ‘æˆä¸ºå®Œå…¨äºŒå‰æ ‘ï¼ˆComplete Binary Treeï¼‰ï¼›
* æ·±åº¦ä¸º k çš„å®Œå…¨äºŒå‰æ ‘ï¼Œè‡³å°‘æœ‰ `2^k` ä¸ªèŠ‚ç‚¹ï¼›
* æœ‰ n ä¸ªèŠ‚ç‚¹çš„å®Œå…¨äºŒå‰æ ‘æ·±åº¦ä¸º `logn + 1`ï¼›

## äºŒå‰æŸ¥æ‰¾æ ‘ Binary Search Tree

###  BST çš„éå†

* BFS: å±‚åºéå†ï¼Œå€ŸåŠ©é˜Ÿåˆ—è¿­ä»£ã€‚
* DFS: å‰ä¸­ååºéå†ï¼Œå€ŸåŠ©æ ˆè¿­ä»£ï¼Œæˆ–è€…é€’å½’ã€‚

# å † Heap

## å®šä¹‰

* å †æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ï¼ˆå®Œå…¨äºŒå‰æ ‘è¦æ±‚ï¼Œé™¤äº†æœ€åä¸€å±‚ï¼Œå…¶ä»–å±‚çš„èŠ‚ç‚¹ä¸ªæ•°éƒ½æ˜¯æ»¡çš„ï¼Œæœ€åä¸€å±‚çš„èŠ‚ç‚¹éƒ½é å·¦æ’åˆ—ï¼‰ã€‚
* å †ä¸­æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¿…é¡»å¤§äºç­‰äºï¼ˆæˆ–å°äºç­‰äºï¼‰å…¶å­æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚

## å­˜å‚¨

æ•°ç»„å­˜å‚¨å®Œå…¨äºŒå‰æ ‘æ¯”è¾ƒèŠ‚çœç©ºé—´ã€‚æ•°ç»„ä¸‹æ ‡ä¸º i çš„èŠ‚ç‚¹ï¼Œå·¦å­èŠ‚ç‚¹ä¸‹æ ‡ä¸º `2*i`ï¼Œå³å­èŠ‚ç‚¹ä¸º `2*i+1`ï¼Œçˆ¶èŠ‚ç‚¹ä¸º `floor((i - 1) / 2)`ã€‚

## æ’å…¥

æ•°æ®æ’å…¥åˆ°å †çš„æœ«å°¾ï¼Œè·Ÿå…¶çˆ¶èŠ‚ç‚¹æ¯”è¾ƒï¼Œå¦‚æœå¤§äºåˆ™äº’æ¢ï¼ˆå¤§é¡¶å †ï¼‰ï¼Œå¾ªç¯åˆ°æ»¡è¶³æ¡ä»¶ä¸ºæ­¢ã€‚

## åˆ é™¤

åˆ é™¤å †é¡¶å…ƒç´ åä»å­èŠ‚ç‚¹ä¸­é€‰å–å †é¡¶ä¼šé€ æˆç©ºæ´ï¼Œæœ‰å¯èƒ½ä¸æ»¡è¶³å®Œå…¨äºŒå‰æ ‘ï¼Œæ‰€ä»¥ä½¿ç”¨è‡ªä¸Šè€Œä¸‹çš„æ–¹å¼ï¼ŒæŠŠæœ«å°¾å…ƒç´ æ”¾åˆ°å †é¡¶ï¼Œå†ä¸å­èŠ‚ç‚¹æ¯”è¾ƒå¤§å°ï¼Œå¦‚æœæ»¡è¶³æ¡ä»¶åˆ™äº’æ¢ï¼Œå¾ªç¯ä¸‹å»ï¼Œä¸æ»¡è¶³æ¡ä»¶å°±è·³å‡ºã€‚

# å›¾

## åŸºæœ¬æ¦‚å¿µ

* æ— å‘å›¾
* æœ‰å‘å›¾
* å›¾çš„å‡ºåº¦ä¸å…¥åº¦
* å¸¦æƒå›¾

## å®ç°å›¾çš„æ•°æ®ç»“æ„

* é‚»æ¥çŸ©é˜µ
* é‚»æ¥è¡¨