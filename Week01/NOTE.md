# 学习笔记

## 7 种常见的时间复杂度 Big O Notation
	* O(1): Constant Complexity 常数时间复杂度
	* O(log n): Logarithmic Complexity 对数复杂度
	* O(n): Linear Complexity 线性时间复杂度
	* O(n^2): N square Complexity 平方
	* O(n^3): N square Complexity 立方
	* O(2^n): Exponential Growth 指数
	* O(n!): Factorial 阶乘 

## 要点
    1. 不考虑前面的系数。
    2. 计算算法的时间复杂度，要看代码或函数根据 n 的不同情况会运行多少次。
    3. 养成习惯，写完程序后下意识的分析时间复杂度和空间复杂度。
    4. 时间复杂度过高，对公司机器资源损耗巨大，反过来则是替公司节约成本。
    5. 示例：自然数累加求和，for 循环累加，时间复杂度 O(n)。高斯求和公式 n * (n + 1) / 2 降为 O(1)。
    6. 解题四件套：
        1. Clarification ，沟通并弄懂题目意思。
        2. Possible Solutions，想所有解题方法，比较时间和空间复杂度。
        3. Coding，找最优时间复杂度的解法，其次找空间复杂度最小的。
        4. Test Cases，写代码及测试结果。
    7. 递归的分析方法，画出状态递归树。
    8. 示例：用递归法求 Fibonacci 数列第 n 项，时间复杂度是 O(k^n)，千万不要用递归的写法，可以将重复计算的中间结果缓存或用循环来实现，可降低时间复杂度到 O(n)。

## Master Theory 主定理
任何分支和递归的程序都可以用主定理求解其时间复杂度。

记住四种递归常用算法的时间复杂度：

    1. 二分查找 O(log n)
    2. 二叉树遍历 O(n)
    3. 最佳排序矩阵搜索(已排好序的二维矩阵) O(n)
    4. 合并排序 O(n * log n)

简化思考方式：二叉树遍历，每个节点访问一次，所以时间复杂度为 O(n)。


## 思考题
    * 二叉树遍历，前中后序时间复杂度是多少？每个节点仅访问一次，所以是 O(n)。
    * 图的遍历，时间复杂度是多少？同上，每个节点仅访问一次，也是 O(n)。
    * 搜索算法，DFS（深度优先）、BFS（广度优先）时间复杂度是多少？同上，每个节点仅访问一次，也是 O(n)。
    * 二分查找，时间复杂度是多少？每次迭代只查找一半，所以是 O(log n)。


## 空间复杂度
    1. 如果使用了数组，一维数组长度就是空间复杂度，二维就是 n^2，多维同理。
    2. 如果使用了递归，递归的最大深度就是其空间复杂度（递归树深度）
    
   参考 [力扣爬楼梯题目官方 Solution](https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/)  。


## 对数及对数复杂度
> 如果 x 的 y 次方等于 n（x > 0，且 x 不等 于 1），那么数 y 叫做以 x 为底 n 的对数（logarithm）。 记作 logxN = y。其中，x 叫做对数的底数。

    1. 底数为 10 时，写为 lg。
    2. 底数为 e 时，称为自然对数写为 ln,这个在高等数学中用的很多。
    3. 底数为 2 时，主要用在计算机中，写为 log，也就是不写底数。

下面例子就是对数复杂度：
```java
for (int i = 2; i < n; i *= 2) {
    System.out.println(i);
}
```

此外，二分查找也是对数复杂度。
