# 学习笔记

## 递归 Recursion

递归其实也是一种循环，从汇编角度来看，都是反复调用一段代码，递归和循环本质上没有明显的边界。

现实中可类比《盗梦空间》，主角携带自己的东西，不断下探到下层梦境，最后再向上返回。每层空间的东西互不影响，其实是一份拷贝。

### 递归代码模板

```java
public void recur(int level, int param) {
  // terminator
  if (level > MAX_LEVEL) {
    // process result
    return;
  }
  // process current logic
  process(level, param);
  // drill down
  recur(level: level + 1, newParam);
  // restore current status
}
```

### 思维要点

	1. 不要人肉递归，这是*最大误区*。
	2. 找到最近最简方法，将其拆解为可重复解决的问题，即找*重复子问题*。
	3. 数学归纳法的思维。

## 分治 Divide and Conquer

> 分治算法（divide and conquer）的核心思想其实就是四个字，分而治之，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

> 分治算法是一种处理问题的思想，递归是一种编程技巧。

### 递归涉及的三个操作

	1. 分解：将原问题分解成一系列子问题；
	2. 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
	3. 合并：将子问题的结果合并成原问题。

### 分治算法的条件

	* 原问题与分解成的小问题具有相同的模式；
	* 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这是分治算法跟动态规划的明显区别；
	* 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；
	* 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。

### 应用

	* 归并排序
	* MapReduce

## 回溯 Backtracking

> 回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。

### 应用

	* 八皇后
	* 数独
	* 0-1 背包
	* 图的着色
	* 旅行商
	* 全排列
	* DFS
	* 正则表达式

